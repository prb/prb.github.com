---
layout: post
title: "Literacy, Sapir-Whorf, and Pointers"
permalink: literacy-sapir-whorf-and-pointers.html
---
<p><a href="http://www.joelonsoftware.com">Joel</a>'s crotchety <a href="http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html">pointer commentary</a> and the ongoing <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=141312">programming</a> <a href="http://www.loudthinking.com/arc/000551.html">language</a> <a href="http://www.onjava.com/pub/a/onjava/2005/10/19/challenging-java-dominance.html">derby</a> are food for thought, albeit that my first thought is about <a href="http://www.imdb.com/title/tt0094012/">Spaceballs</a> &#8212; "I see your Schwartz is as big as mine."</p>

<p>I have nothing against pointers, used recreationally or even by trained professionals, and I had a good time teaching data structures and algorithms in C during one of my semesters at <a href="http://www.math.uic.edu">UIC</a>.  (I probably had a good time because my idea of fun includes anything that combines colored chalk and running around in front of a captive audience for an hour.)  It is my considered opinion that working with pointers is not particularly <em>challenging</em> other than that it can be tedious, and in the sense that working with pointers is good for punishing carelessness or sloppiness, I can see value in it as a teaching tool.  As <a href="http://www.dehora.net/journal/">Bill de H&oacute;ra</a> <a href="http://www.dehora.net/journal/2005/12/difficult_v_hard_as_opposed_to_java_v_c.html">points out</a>, concurrent programming in Java, especially pre-<a href="http://www.jcp.org/jsr/detail/166.jsp">JSR166</a>, provides a similar proving ground.  I'm open to arguments as to why pointers help people build better software or help groups of people collaborate on large pieces of software, but I'm not going to hold my breath.</p>

<p>On the subject of different languages, Paul Graham has the following restatement of the <a href="http://en.wikipedia.org/wiki/Sapir-Whorf_Hypothesis.html">Sapir-Whorf hypothesis</a> (linguistic determinism) in the preface to his <a href="http://www.amazon.com/gp/product/0133708756">ANSI Common Lisp</a> book:</p>

<blockquote><small>Programming languages teach you not to want what they cannot provide.  You have to think in a language to write programs in it, and it's hard to want something that you can't describe.</small></blockquote>

<p>To strengthen the analogy with Sapir-Whorf, this statement is false, as it would preclude the creation of any programming language ever, but it poses an interesting question about how important language features are to programming.  For contrast, here's a quote from <a href="http://www-cs-faculty.stanford.edu/~knuth/">Knuth</a>'s classic <a href="http://www.literateprogramming.com/knuthweb.pdf">article</a> on <a href="http://www.literateprogramming.com">literate programming</a>:</p>

<blockquote><small>Let us change our traditional attitude to the construction of programs: Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.</small></blockquote>

<p>For me, this would be the yardstick by which to measure language features against the task at hand.</p>
