---
layout: post
title: "Actors, Scala, and JaCOb"
permalink: actors-scala-and-jacob.html
categories: [concurrency, java, threads, pxe, jacob, scala, actors, martinodersky, phillipphaller]
---
<p><a href="http://lambda-the-ultimate.org/">LtU</a> carried an announcement of a <a href="http://lampwww.epfl.ch/~odersky/papers/jmlc06.pdf">paper</a> from <a href="http://lampwww.epfl.ch/~odersky/">Martin Odersky</a> and Phillipp Haller at <a href="http://www.epfl.ch/Eindex.html">EPFL</a> called &#8220;Event-Based Programming without Inversion of Control&#8221;.  To quote a snippet:</p>

<blockquote><small>The central idea is as follows: An actor that waits in a receive statement is not represented by a blocked thread but by a closure that captures the rest of the actors computation.  The closure is executed once a message is set to the actor that matches one of the message patterns specified in the receive.  The executing closure is &#8220;piggy-backed&#8221; on the thread of the sender.  If the receiving closure terminates, control is returned to the sender as if a procedure returns.  If the receiving closure blocks in a second receive, control is returned to the sender by throwing a special exception that unwinds the receiver's call stack.</small></blockquote>

<p>Scala has had <a href="http://www.erights.org/history/actors.html">actors</a> in the form of <a href="http://scala.epfl.ch/docu/files/api/scala/concurrent/Actor.html"><tt>scala.concurrent.Actor</tt></a> since version 1.x, but as extensions of <tt>java.lang.Thread</tt> they are thread-dependent.  Thread-dependent means that a Scala <tt>Actor</tt> might be preferable to a Java <tt>Thread</tt> for semantic reasons but that there is no performance advantage.  (In fact, a benchmark in the paper shows that it's a disadvantage, but semantics are often more important than raw performance.)</p>

<p>The <a href="http://pxe.intalio.org/">PXE</a> BPEL engine relies on a little-publicized Java-based actor framework called JaCOb (short for &#8220;<em>Ja</em>va <em>C</em>oncurrent <em>Ob</em>jects&#8221;) that makes some different choices than Martin and Phillipp did but that is ultimately based on hooking closures to model the receipt of messages in the future.  For a quick tour of JaCOb, there's either the <a href="http://svn.apache.org/repos/asf/incubator/ode/scratch/pxe/jacob/">source code</a> or a detailed <a href="http://wiki.apache.org/ode/Jacob">tutorial</a> written by <a href="http://www.jroller.com/page/mriou">Matthieu Riou</a> on the Apache <a href="http://incubator.apache.org/projects/ode.html">Ode</a> incubation wiki.)  For one, JaCOb's syntax would be cleaner in Scala, as Java lacks <a href="http://en.wikipedia.org/wiki/Delegation_%28programming%29">delegates</a>.  JaCOb does not use exceptions to break the stack but instead relies on passing communication channels.  (Using exceptions for control flow is <a href="http://java.sun.com/docs/books/effective/">generally regarded</a> as a bad thing to do.  In addition to the philosophical reasons, throwing an exception is <a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/Concepts.doc.html#22727">involved</a> and, depending on the JVM implementation (e.g., implementing exceptions as <a href="http://en.wikipedia.org/wiki/Signal_%28computing%29">signals</a>), can be expensive.)  JaCOb doesn't include explicit support for distributed operation as Martin and Phillipp describe for their framework, but a suitable flavor of JaCOb's soup could be implemented.</p>

<p>I'm looking forward to checking out the event-based approach from Martin and Phillipp when it comes out with Scala 2.1.7, and in the meantime, I should finish up the JaCOb tutorial that's been mouldering on my to-do list.</p>
